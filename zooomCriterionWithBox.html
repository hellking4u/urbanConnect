<html>

<head>
  <style>
    .interactable-zoom {
      -webkit-transition: 0.1s ease-in-out;
      -moz-transition: 0.1s ease-in-out;
      -o-transition: 0.1s ease-in-out;
      transition: 0.1s ease-in-out;
    }
  </style>
</head>

<body>

  <script src="https://js.leapmotion.com/leap-0.6.4.js"></script>
  <div id="debug-box" class="interactable-zoom" style="background-color: #f2f2f2;width: 200;height: 100;position: fixed;right: 10;top: 10;">-41,128,201</div>

  <div id="stage" style="background-color:rgb(191,191,191); width:1400; height:600;position: fixed;">
    <div id="box1" class="interactable-zoom" style="background-color: #f2f2f2;width: 100;height: 100;position: absolute;left: 10;top: 10;">-Box 1</div>
    <div id="box2" class="interactable-zoom" style="background-color: #D64A4A;width: 100;height: 100;position: absolute;left: 300;top: 10;">Box 2</div>
    <div id="box3" class="interactable-zoom" style="background-color: #D64A4A;width: 100;height: 100;position: absolute;left: 500;top: 10;">Box 3</div>

  </div>
  <script>
    const debugBox = document.getElementById("debug-box");
    const stageDiv = document.getElementById("stage");
    const box2 = document.getElementById("box2");
    const vPlaneDelta = 50;
    const stageScalingFactor = 1000;

    var vPlaneZ = screenZ + vPlaneDelta;
    var screenZ = -120;
    var interactionBox = [[-45, 240], [40, 310]];
    var calibrationLevel = -1;
    const defInteractionBox = [[-25.5077, 301.73], [30.6594, 249.462]];
    const stage = [[-25.5077, 301.73], [30.6594, 249.462]];

    function transformBox(tipPos, box, scaleDelta) {

      var relativePosition = getRelativeNormalizedPosition(box);
      let finger = getNormalizedPointer(tipPos);
      const x = finger[0];
      const y = finger[1];
      const z = finger[2];

      let zoomFactor = 1 + ((z - vPlaneZ) / (screenZ - vPlaneZ)) * scaleDelta;

      if (x > relativePosition.right || x < relativePosition.left || y < relativePosition.top || y > relativePosition.bottom)
        zoomFactor = 1
      if (z > vPlaneZ)
        zoomFactor = 1;

      zoomFactor = isNaN(zoomFactor) ? 1 : zoomFactor.toPrecision(3);
      zoomFactor = (1 + scaleDelta < zoomFactor) ? (1 + scaleDelta) : zoomFactor;
      box.style.transform = `scale(${zoomFactor},${zoomFactor})`
    }
    // function

    function zoomBoxes(tipPos, scaleDelta = 0.5) {

      boxes = document.getElementsByClassName("interactable-zoom");
      Array.from(boxes).forEach(box => { transformBox(tipPos, box, scaleDelta) });
    }
    function getRelativeNormalizedPosition(box) {

      // normalized distance from top left
      const parentPos = stageDiv.getBoundingClientRect();
      const childrenPos = box.getBoundingClientRect();

      const stageHeight = parentPos.height;
      const stageWidth = parentPos.width;
      relativePos = {};
      relativePos.top = ((childrenPos.top - parentPos.top) / stageHeight) * stageScalingFactor,
        relativePos.right = ((childrenPos.right - parentPos.left) / stageWidth) * stageScalingFactor,
        relativePos.bottom = ((childrenPos.bottom - parentPos.top) / stageHeight) * stageScalingFactor,
        relativePos.left = ((childrenPos.left - parentPos.left) / stageWidth) * stageScalingFactor;
      return relativePos
    }

    function getNormalizedPointer(fingerPos) {
      let width = stage[1][0] - stage[0][0];
      let height = stage[0][1] - stage[1][1];

      let pointerX = fingerPos[0] - stage[0][0];
      let pointerY = stage[0][1] - fingerPos[1];
      return [(pointerX / width) * stageScalingFactor, (pointerY / height) * stageScalingFactor, fingerPos[2]];
    }

    function calibrateStage(tipPos) {
      console.log('start calibration');
      if (calibrationLevel < 1) {
        calibrationLevel = 1;
        console.log('calibration level 1');
        stage[0][0] = tipPos[0];
        stage[0][1] = tipPos[1];
        console.log(interactionBox);
        screenZ = tipPos[2];
        vPlaneZ = screenZ + vPlaneDelta;
        return 0;
      } else if (calibrationLevel === 1) {
        console.log('calibration level 2');
        calibrationLevel = 0;
        stage[1][0] = tipPos[0];
        stage[1][1] = tipPos[1];
        screenZ = tipPos[2];
        vPlaneZ = screenZ + vPlaneDelta;
        console.log(interactionBox);
      }
      console.log(`Calibration Level ${calibrationLevel}`)
    }

    Leap.loop(function (frame) {

      if (frame.hands.length > 0) {
        debugBox.innerHTML = "";
        const finger = frame.hands[0].indexFinger;
        debugBox.innerHTML += getNormalizedPointer(finger.tipPosition).map(val => Math.round(val));
        debugBox.innerHTML += '<br />';
        debugBox.innerHTML += finger.tipPosition.map(val => Math.round(val));
        debugBox.innerHTML += '<br />';
        var rect = debugBox.getBoundingClientRect();
        debugBox.innerHTML += `Box pos : ${Math.round(rect.top)}, ${Math.round(rect.right)}, ${Math.round(rect.bottom)}, ${Math.round(rect.left)}`;
        debugBox.innerHTML += '<br />';

        if (calibrationLevel === 0) {
          zoomBoxes(finger.tipPosition, scaleDelta = 0.3);
        }
        document.onkeypress = function (oPEvt) {
          var oEvent = oPEvt || window.event, nChr = oEvent.charCode;
          if (nChr == 99) {
            calibrateStage(finger.tipPosition);
          }
        }
      }

      // console.log(frame.hands[0].fingers);
    });
  </script>
  <link href="/style.css">
</body>

</html>